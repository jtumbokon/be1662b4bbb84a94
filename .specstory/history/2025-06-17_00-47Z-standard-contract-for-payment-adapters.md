<!-- Generated by SpecStory -->

# Standard contract for payment adapters (2025-06-17 00:47Z)

_**User**_

We want to support lemon squeezy, stripe and polar SH payments. Help me come up with a standard abstract contract that our adapters will comply with. @Web Use Next.js best practices in enterprise apps.

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants to create a standard abstract contract/interface for payment adapters that will support LemonSqueezy, Stripe, and Polar SH payments. They want this to follow Next.js best practices in enterprise applications.

Let me first research the latest Next.js best practices for enterprise payment integration, then analyze the current codebase to understand the existing structure.

I should:
1. Use web search to get current best practices for payment integrations in Next.js enterprise apps
2. Look at the existing payment provider structure in the codebase
3. Create a comprehensive abstract contract that can handle all three payment providers
4. Follow TypeScript best practices and enterprise patterns</details></think>

---

I'll help you create a robust abstract contract for payment adapters supporting LemonSqueezy, Stripe, and Polar SH. Let me first research the latest Next.js enterprise best practices for payment integrations, then examine your current codebase structure.

---

<details>
            <summary>Searched web "Next.js enterprise payment gateway integration best practices 2024 TypeScript abstract interfaces adapters" • **5** results</summary>
        
| Title | URL |
|-------|-----|
| Mastering NextJS Architecture with TypeScript in Mind | https://sviat-kuzhelev.medium.com/mastering-nextjs-architecture-with-typescript-in-mind-design-abstractions-2024-a6f9612300d1 |
| Modern API Development with Node.js, Express, and ... | https://baguilar6174.medium.com/modern-api-development-with-node-js-express-and-typescript-using-clean-architecture-0868607b76de |
| GitHub - jsdevman/next-stripe-integration: Next.js, TypeScript React Stripe | https://github.com/jsdevman/next-stripe-integration |
| Stripe Checkout and Webhook in a Next.js 15 (2025) - John Gragson - Medium | https://medium.com/@gragson.john/stripe-checkout-and-webhook-in-a-next-js-15-2025-925d7529855e |
| Stripe Checkout and Webhook in a Next.js Application | https://www.pedroalonso.net/blog/stripe-checkout-nextjs/ |

</details>

---

Now, let me examine your current payment provider structure to understand the existing patterns and design a comprehensive abstract contract.

---

<details>
            <summary>Searched codebase "payment provider interface adapter LemonSqueezy Stripe Polar payment service" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/server/services/payment-service.ts` | L66-68 |
| `src/types/payments.ts` | L1-4 |
| `src/server/providers/index.ts` | L16-77 |
| `src/types/lemonsqueezy.ts` | L206-223 |
| `src/server/providers/lemonsqueezy-provider.ts` | L1-47 |
| `src/server/providers/lemonsqueezy-provider.ts` | L47-87 |
| `src/server/providers/lemonsqueezy-provider.ts` | L428-475 |
| `src/server/services/payment-service.ts` | L68-135 |
| `src/app/(app)/(admin)/admin/payments/_components/import-payments.tsx` | L26-31 |
| `src/server/providers/lemonsqueezy-provider.ts` | L405-428 |
| `src/server/providers/lemonsqueezy-provider.ts` | L344-405 |
| `src/server/providers/lemonsqueezy-provider.ts` | L496-530 |
| `src/server/providers/lemonsqueezy-provider.ts` | L475-496 |
| `src/server/providers/lemonsqueezy-provider.ts` | L221-277 |
| `src/server/providers/lemonsqueezy-provider.ts` | L579-600 |
| `src/server/providers/lemonsqueezy-provider.ts` | L277-344 |
| `src/server/providers/lemonsqueezy-provider.ts` | L167-221 |
| `src/server/providers/lemonsqueezy-provider.ts` | L818-843 |
| `src/app/(app)/(admin)/admin/payments/_components/import-payments.tsx` | L31-47 |
| `src/server/providers/lemonsqueezy-provider.ts` | L87-128 |
| `src/server/providers/lemonsqueezy-provider.ts` | L843-877 |
| `src/server/providers/lemonsqueezy-provider.ts` | L128-167 |
| `src/server/providers/lemonsqueezy-provider.ts` | L790-818 |
| `src/server/actions/payments.ts` | L126-156 |
| `src/server/providers/polar-provider.ts` | L245-303 |

</details>

---

Let me now examine the base provider interface and understand the current structure better:

---

Read file: src/server/providers/base-provider.ts

---

Now let me examine the types file to understand the current interfaces:

---

Read file: src/server/providers/types.ts

---

Now let me look at how Stripe is currently implemented or referenced in the codebase:

---

<details>
            <summary>Searched codebase "Stripe payment provider implementation adapter interface" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/server/providers/stripe-provider.ts` | L34-91 |
| `src/server/providers/stripe-provider.ts` | L534-548 |
| `src/server/providers/types.ts` | L69-104 |
| `src/server/providers/stripe-provider.ts` | L91-113 |
| `src/server/providers/stripe-provider.ts` | L250-284 |
| `src/types/stripe.ts` | L28-48 |
| `src/types/stripe.ts` | L1-28 |
| `src/server/providers/stripe-provider.ts` | L303-322 |
| `src/server/providers/stripe-provider.ts` | L1-34 |
| `src/server/providers/index.ts` | L77-114 |
| `src/server/providers/stripe-provider.ts` | L510-534 |
| `src/server/providers/stripe-provider.ts` | L477-510 |
| `src/server/providers/stripe-provider.ts` | L284-303 |
| `src/server/providers/stripe-provider.ts` | L135-177 |
| `src/server/providers/stripe-provider.ts` | L113-135 |
| `src/server/providers/stripe-provider.ts` | L396-436 |
| `src/server/providers/stripe-provider.ts` | L177-250 |
| `src/server/providers/stripe-provider.ts` | L322-396 |
| `src/types/stripe.ts` | L125-137 |
| `src/server/providers/base-provider.ts` | L1-31 |
| `docs/integrations/stripe-implementation-plan.md` | L131-182 |
| `src/types/stripe.ts` | L137-154 |
| `src/types/stripe.ts` | L95-110 |
| `src/types/stripe.ts` | L154-170 |
| `src/types/stripe.ts` | L48-63 |

</details>

---

Based on my analysis of your current codebase and the research on Next.js enterprise best practices, I can see you already have a well-structured payment provider system. Let me create an enhanced abstract contract that follows enterprise patterns and supports all three payment providers (LemonSqueezy, Stripe, and Polar SH).

Here's my recommended enhanced abstract contract:

```typescript:src/server/providers/enhanced-payment-adapter.ts
import { logger } from "@/lib/logger";
import { db } from "@/server/db";
import { users } from "@/server/db/schema";
import { eq } from "drizzle-orm";

/**
 * Enhanced payment adapter contract following enterprise patterns
 * Supports LemonSqueezy, Stripe, and Polar SH payments
 * 
 * @see https://stripe.com/docs/api
 * @see https://docs.lemonsqueezy.com/api
 * @see https://docs.polar.sh/api
 */

/**
 * Payment method types supported across providers
 */
export enum PaymentMethod {
	CARD = "card",
	BANK_TRANSFER = "bank_transfer",
	DIGITAL_WALLET = "digital_wallet",
	CRYPTOCURRENCY = "cryptocurrency",
	BUY_NOW_PAY_LATER = "bnpl",
}

/**
 * Payment status unified across all providers
 */
export enum PaymentStatus {
	PENDING = "pending",
	PROCESSING = "processing",
	COMPLETED = "completed",
	FAILED = "failed",
	CANCELED = "canceled",
	REFUNDED = "refunded",
	DISPUTED = "disputed",
	PARTIALLY_REFUNDED = "partially_refunded",
}

/**
 * Subscription status unified across all providers
 */
export enum SubscriptionStatus {
	ACTIVE = "active",
	TRIALING = "trialing",
	PAST_DUE = "past_due",
	CANCELED = "canceled",
	UNPAID = "unpaid",
	INCOMPLETE = "incomplete",
	INCOMPLETE_EXPIRED = "incomplete_expired",
	PAUSED = "paused",
}

/**
 * Enhanced customer data interface
 */
export interface CustomerData {
	readonly id: string;
	readonly email: string;
	readonly name?: string;
	readonly phone?: string;
	readonly address?: AddressData;
	readonly metadata?: Record<string, unknown>;
	readonly createdAt: Date;
	readonly updatedAt: Date;
	readonly provider: string;
}

/**
 * Address data structure
 */
export interface AddressData {
	readonly line1: string;
	readonly line2?: string;
	readonly city: string;
	readonly state?: string;
	readonly postalCode: string;
	readonly country: string;
}

/**
 * Enhanced product data interface
 */
export interface EnhancedProductData {
	readonly id: string;
	readonly name: string;
	readonly description?: string;
	readonly price: number;
	readonly currency: string;
	readonly isSubscription: boolean;
	readonly isActive: boolean;
	readonly category?: string;
	readonly metadata?: Record<string, unknown>;
	readonly images?: string[];
	readonly provider: string;
	readonly createdAt: Date;
	readonly updatedAt: Date;
	// Subscription-specific fields
	readonly interval?: "day" | "week" | "month" | "year";
	readonly intervalCount?: number;
	readonly trialPeriodDays?: number;
}

/**
 * Enhanced order data interface
 */
export interface EnhancedOrderData {
	readonly id: string;
	readonly orderId: string;
	readonly customerId?: string;
	readonly customerEmail: string;
	readonly customerName?: string;
	readonly amount: number;
	readonly currency: string;
	readonly status: PaymentStatus;
	readonly paymentMethod?: PaymentMethod;
	readonly products: OrderLineItem[];
	readonly discountAmount?: number;
	readonly discountCode?: string;
	readonly taxAmount?: number;
	readonly shippingAmount?: number;
	readonly totalAmount: number;
	readonly billingAddress?: AddressData;
	readonly shippingAddress?: AddressData;
	readonly processor: string;
	readonly processorOrderId: string;
	readonly webhookEvents?: WebhookEvent[];
	readonly metadata?: Record<string, unknown>;
	readonly createdAt: Date;
	readonly updatedAt: Date;
	readonly completedAt?: Date;
	readonly refundedAt?: Date;
}

/**
 * Order line item interface
 */
export interface OrderLineItem {
	readonly id: string;
	readonly productId: string;
	readonly productName: string;
	readonly variantId?: string;
	readonly variantName?: string;
	readonly quantity: number;
	readonly unitPrice: number;
	readonly totalPrice: number;
	readonly currency: string;
	readonly metadata?: Record<string, unknown>;
}

/**
 * Enhanced subscription data interface
 */
export interface SubscriptionData {
	readonly id: string;
	readonly customerId: string;
	readonly productId: string;
	readonly priceId: string;
	readonly status: SubscriptionStatus;
	readonly currentPeriodStart: Date;
	readonly currentPeriodEnd: Date;
	readonly trialStart?: Date;
	readonly trialEnd?: Date;
	readonly cancelAtPeriodEnd: boolean;
	readonly canceledAt?: Date;
	readonly endedAt?: Date;
	readonly quantity: number;
	readonly unitAmount: number;
	readonly currency: string;
	readonly interval: "day" | "week" | "month" | "year";
	readonly intervalCount: number;
	readonly provider: string;
	readonly metadata?: Record<string, unknown>;
	readonly createdAt: Date;
	readonly updatedAt: Date;
}

/**
 * Webhook event interface
 */
export interface WebhookEvent {
	readonly id: string;
	readonly type: string;
	readonly data: Record<string, unknown>;
	readonly receivedAt: Date;
	readonly processed: boolean;
	readonly error?: string;
}

/**
 * Enhanced checkout options interface
 */
export interface EnhancedCheckoutOptions {
	readonly productId: string;
	readonly priceId?: string;
	readonly quantity?: number;
	readonly customerId?: string;
	readonly customerEmail?: string;
	readonly customerName?: string;
	readonly mode: "payment" | "subscription" | "setup";
	readonly paymentMethods?: PaymentMethod[];
	readonly allowPromotionCodes?: boolean;
	readonly discountCode?: string;
	readonly taxRates?: string[];
	readonly shippingOptions?: ShippingOption[];
	readonly billingAddressCollection?: "auto" | "required";
	readonly shippingAddressCollection?: "auto" | "required";
	readonly metadata?: Record<string, unknown>;
	readonly successUrl: string;
	readonly cancelUrl: string;
	readonly locale?: string;
	readonly currency?: string;
	// Subscription-specific options
	readonly trialPeriodDays?: number;
	readonly subscriptionData?: {
		readonly description?: string;
		readonly metadata?: Record<string, unknown>;
	};
}

/**
 * Shipping option interface
 */
export interface ShippingOption {
	readonly id: string;
	readonly displayName: string;
	readonly amount: number;
	readonly currency: string;
	readonly deliveryEstimate?: {
		readonly minimum: number;
		readonly maximum: number;
		readonly type: "business_day" | "day" | "hour";
	};
}

/**
 * Enhanced import statistics interface
 */
export interface EnhancedImportStats {
	readonly total: number;
	readonly imported: number;
	readonly updated: number;
	readonly skipped: number;
	readonly errors: number;
	readonly customersCreated: number;
	readonly customersUpdated: number;
	readonly warnings: string[];
	readonly startedAt: Date;
	readonly completedAt: Date;
	readonly duration: number; // milliseconds
}

/**
 * Enhanced provider configuration interface
 */
export interface EnhancedProviderConfig {
	readonly apiKey: string;
	readonly webhookSecret?: string;
	readonly publishableKey?: string;
	readonly environment: "sandbox" | "production";
	readonly enabled: boolean;
	readonly baseUrl?: string;
	readonly timeout?: number;
	readonly retryConfig?: RetryConfig;
	readonly featureFlags?: Record<string, boolean>;
	readonly metadata?: Record<string, unknown>;
}

/**
 * Retry configuration interface
 */
export interface RetryConfig {
	readonly maxRetries: number;
	readonly backoffMultiplier: number;
	readonly maxBackoffTime: number;
	readonly retryableErrors: string[];
}

/**
 * Payment provider capabilities interface
 */
export interface ProviderCapabilities {
	readonly supportsSubscriptions: boolean;
	readonly supportsRefunds: boolean;
	readonly supportsPartialRefunds: boolean;
	readonly supportsDisputes: boolean;
	readonly supportsWebhooks: boolean;
	readonly supportsMultiCurrency: boolean;
	readonly supportedPaymentMethods: PaymentMethod[];
	readonly supportedCountries: string[];
	readonly supportedCurrencies: string[];
	readonly minimumAmount: Record<string, number>; // currency -> minimum amount
	readonly maximumAmount: Record<string, number>; // currency -> maximum amount
}

/**
 * Validation result interface
 */
export interface ValidationResult {
	readonly isValid: boolean;
	readonly errors: ValidationError[];
	readonly warnings: ValidationWarning[];
}

/**
 * Validation error interface
 */
export interface ValidationError {
	readonly field: string;
	readonly code: string;
	readonly message: string;
	readonly value?: unknown;
}

/**
 * Validation warning interface
 */
export interface ValidationWarning {
	readonly field: string;
	readonly code: string;
	readonly message: string;
	readonly value?: unknown;
}

/**
 * Enhanced payment provider error class
 */
export class EnhancedPaymentProviderError extends Error {
	constructor(
		message: string,
		public readonly provider: string,
		public readonly code: string,
		public readonly statusCode?: number,
		public readonly retryable: boolean = false,
		public readonly originalError?: Error,
		public readonly metadata?: Record<string, unknown>
	) {
		super(message);
		this.name = "EnhancedPaymentProviderError";
		
		// Maintain proper prototype chain
		Object.setPrototypeOf(this, EnhancedPaymentProviderError.prototype);
	}

	/**
	 * Convert to a serializable object for logging and API responses
	 */
	toJSON(): Record<string, unknown> {
		return {
			name: this.name,
			message: this.message,
			provider: this.provider,
			code: this.code,
			statusCode: this.statusCode,
			retryable: this.retryable,
			metadata: this.metadata,
			stack: this.stack,
		};
	}
}

/**
 * Abstract enhanced payment adapter interface
 * All payment providers must implement this interface
 */
export interface IEnhancedPaymentAdapter {
	// Provider identity and capabilities
	readonly name: string;
	readonly id: string;
	readonly version: string;
	readonly isConfigured: boolean;
	readonly isEnabled: boolean;
	readonly capabilities: ProviderCapabilities;

	// Configuration and lifecycle management
	initialize(config: EnhancedProviderConfig): Promise<void>;
	validateConfig(config: EnhancedProviderConfig): ValidationResult;
	healthCheck(): Promise<boolean>;
	getStatus(): Promise<{
		isHealthy: boolean;
		lastChecked: Date;
		responseTime: number;
		errors?: string[];
	}>;

	// Customer management
	createCustomer(data: Partial<CustomerData>): Promise<CustomerData>;
	getCustomer(customerId: string): Promise<CustomerData | null>;
	getCustomerByEmail(email: string): Promise<CustomerData | null>;
	updateCustomer(customerId: string, data: Partial<CustomerData>): Promise<CustomerData>;
	deleteCustomer(customerId: string): Promise<boolean>;
	listCustomers(params?: {
		limit?: number;
		offset?: number;
		email?: string;
		createdAfter?: Date;
		createdBefore?: Date;
	}): Promise<{ customers: CustomerData[]; hasMore: boolean; total?: number }>;

	// Product management
	createProduct(data: Partial<EnhancedProductData>): Promise<EnhancedProductData>;
	getProduct(productId: string): Promise<EnhancedProductData | null>;
	updateProduct(productId: string, data: Partial<EnhancedProductData>): Promise<EnhancedProductData>;
	deleteProduct(productId: string): Promise<boolean>;
	listProducts(params?: {
		limit?: number;
		offset?: number;
		isActive?: boolean;
		category?: string;
	}): Promise<{ products: EnhancedProductData[]; hasMore: boolean; total?: number }>;

	// Payment operations
	getPaymentStatus(userId: string): Promise<boolean>;
	hasUserPurchasedProduct(userId: string, productId: string): Promise<boolean>;
	hasUserPurchasedVariant?(userId: string, variantId: string): Promise<boolean>;
	getUserPurchasedProducts(userId: string): Promise<EnhancedProductData[]>;
	processPayment(paymentData: {
		customerId: string;
		amount: number;
		currency: string;
		paymentMethod: PaymentMethod;
		metadata?: Record<string, unknown>;
	}): Promise<EnhancedOrderData>;
	refundPayment(
		orderId: string,
		amount?: number,
		reason?: string
	): Promise<{
		refundId: string;
		amount: number;
		status: PaymentStatus;
		reason?: string;
	}>;

	// Order management
	getOrder(orderId: string): Promise<EnhancedOrderData | null>;
	getOrdersByCustomer(customerId: string): Promise<EnhancedOrderData[]>;
	getOrdersByEmail(email: string): Promise<EnhancedOrderData[]>;
	getAllOrders(params?: {
		limit?: number;
		offset?: number;
		status?: PaymentStatus;
		createdAfter?: Date;
		createdBefore?: Date;
	}): Promise<{ orders: EnhancedOrderData[]; hasMore: boolean; total?: number }>;
	updateOrderMetadata(orderId: string, metadata: Record<string, unknown>): Promise<boolean>;

	// Subscription management
	hasUserActiveSubscription(userId: string): Promise<boolean>;
	createSubscription(data: {
		customerId: string;
		priceId: string;
		quantity?: number;
		trialPeriodDays?: number;
		metadata?: Record<string, unknown>;
	}): Promise<SubscriptionData>;
	getSubscription(subscriptionId: string): Promise<SubscriptionData | null>;
	getSubscriptionsByCustomer(customerId: string): Promise<SubscriptionData[]>;
	updateSubscription(
		subscriptionId: string,
		data: Partial<SubscriptionData>
	): Promise<SubscriptionData>;
	cancelSubscription(
		subscriptionId: string,
		cancelAtPeriodEnd?: boolean
	): Promise<SubscriptionData>;
	pauseSubscription(subscriptionId: string): Promise<SubscriptionData>;
	resumeSubscription(subscriptionId: string): Promise<SubscriptionData>;

	// Checkout and payment flow
	createCheckoutSession(options: EnhancedCheckoutOptions): Promise<{
		sessionId: string;
		url: string;
		expiresAt: Date;
	}>;
	createCheckoutUrl(options: EnhancedCheckoutOptions): Promise<string>;
	getCheckoutSession(sessionId: string): Promise<{
		id: string;
		status: string;
		paymentStatus: string;
		customerId?: string;
		metadata?: Record<string, unknown>;
	} | null>;

	// Webhook management
	handleWebhookEvent(event: {
		id: string;
		type: string;
		data: Record<string, unknown>;
		signature?: string;
		timestamp?: Date;
	}): Promise<void>;
	verifyWebhookSignature(payload: string, signature: string): boolean;
	getWebhookEvents(params?: {
		limit?: number;
		offset?: number;
		type?: string;
		processed?: boolean;
	}): Promise<{ events: WebhookEvent[]; hasMore: boolean }>;

	// Data import and export
	importPayments(options?: {
		startDate?: Date;
		endDate?: Date;
		dryRun?: boolean;
	}): Promise<EnhancedImportStats>;
	exportOrders(params: {
		format: "csv" | "json" | "xlsx";
		startDate?: Date;
		endDate?: Date;
		status?: PaymentStatus[];
	}): Promise<{
		url: string;
		expiresAt: Date;
		totalRecords: number;
	}>;

	// Analytics and reporting
	getAnalytics(params: {
		startDate: Date;
		endDate: Date;
		granularity: "day" | "week" | "month";
		metrics: ("revenue" | "orders" | "customers" | "subscriptions")[];
	}): Promise<{
		metrics: Record<string, Array<{ date: Date; value: number }>>;
		totals: Record<string, number>;
	}>;

	// Utility methods
	validatePaymentData(data: unknown): ValidationResult;
	sanitizeCustomerData(data: Partial<CustomerData>): Partial<CustomerData>;
	formatAmount(amount: number, currency: string): string;
	parseAmount(formattedAmount: string, currency: string): number;
	getSupportedCurrencies(): string[];
	getMinimumAmount(currency: string): number;
	getMaximumAmount(currency: string): number;
}

/**
 * Abstract base implementation with common functionality
 */
export abstract class EnhancedPaymentAdapter implements IEnhancedPaymentAdapter {
	// Provider identity - must be implemented by subclasses
	abstract readonly name: string;
	abstract readonly id: string;
	abstract readonly version: string;
	abstract readonly capabilities: ProviderCapabilities;

	// Provider state
	protected _config?: EnhancedProviderConfig;
	protected _isConfigured = false;
	protected _isEnabled = false;
	protected _lastHealthCheck?: Date;
	protected _isHealthy = false;

	// Getters
	get isConfigured(): boolean {
		return this._isConfigured;
	}

	get isEnabled(): boolean {
		return this._isEnabled && this._isConfigured;
	}

	// Abstract methods that must be implemented by subclasses
	abstract initialize(config: EnhancedProviderConfig): Promise<void>;
	abstract validateConfig(config: EnhancedProviderConfig): ValidationResult;
	abstract healthCheck(): Promise<boolean>;

	// Customer management - must be implemented
	abstract createCustomer(data: Partial<CustomerData>): Promise<CustomerData>;
	abstract getCustomer(customerId: string): Promise<CustomerData | null>;
	abstract getCustomerByEmail(email: string): Promise<CustomerData | null>;
	abstract updateCustomer(customerId: string, data: Partial<CustomerData>): Promise<CustomerData>;
	abstract deleteCustomer(customerId: string): Promise<boolean>;
	abstract listCustomers(params?: {
		limit?: number;
		offset?: number;
		email?: string;
		createdAfter?: Date;
		createdBefore?: Date;
	}): Promise<{ customers: CustomerData[]; hasMore: boolean; total?: number }>;

	// Payment operations - must be implemented
	abstract getPaymentStatus(userId: string): Promise<boolean>;
	abstract hasUserPurchasedProduct(userId: string, productId: string): Promise<boolean>;
	abstract getUserPurchasedProducts(userId: string): Promise<EnhancedProductData[]>;
	abstract processPayment(paymentData: {
		customerId: string;
		amount: number;
		currency: string;
		paymentMethod: PaymentMethod;
		metadata?: Record<string, unknown>;
	}): Promise<EnhancedOrderData>;
	abstract refundPayment(
		orderId: string,
		amount?: number,
		reason?: string
	): Promise<{
		refundId: string;
		amount: number;
		status: PaymentStatus;
		reason?: string;
	}>;

	// Order management - must be implemented
	abstract getOrder(orderId: string): Promise<EnhancedOrderData | null>;
	abstract getOrdersByCustomer(customerId: string): Promise<EnhancedOrderData[]>;
	abstract getOrdersByEmail(email: string): Promise<EnhancedOrderData[]>;
	abstract getAllOrders(params?: {
		limit?: number;
		offset?: number;
		status?: PaymentStatus;
		createdAfter?: Date;
		createdBefore?: Date;
	}): Promise<{ orders: EnhancedOrderData[]; hasMore: boolean; total?: number }>;
	abstract updateOrderMetadata(orderId: string, metadata: Record<string, unknown>): Promise<boolean>;

	// Subscription management - must be implemented
	abstract hasUserActiveSubscription(userId: string): Promise<boolean>;
	abstract createSubscription(data: {
		customerId: string;
		priceId: string;
		quantity?: number;
		trialPeriodDays?: number;
		metadata?: Record<string, unknown>;
	}): Promise<SubscriptionData>;
	abstract getSubscription(subscriptionId: string): Promise<SubscriptionData | null>;
	abstract getSubscriptionsByCustomer(customerId: string): Promise<SubscriptionData[]>;
	abstract updateSubscription(
		subscriptionId: string,
		data: Partial<SubscriptionData>
	): Promise<SubscriptionData>;
	abstract cancelSubscription(
		subscriptionId: string,
		cancelAtPeriodEnd?: boolean
	): Promise<SubscriptionData>;
	abstract pauseSubscription(subscriptionId: string): Promise<SubscriptionData>;
	abstract resumeSubscription(subscriptionId: string): Promise<SubscriptionData>;

	// Checkout operations - must be implemented
	abstract createCheckoutSession(options: EnhancedCheckoutOptions): Promise<{
		sessionId: string;
		url: string;
		expiresAt: Date;
	}>;
	abstract createCheckoutUrl(options: EnhancedCheckoutOptions): Promise<string>;
	abstract getCheckoutSession(sessionId: string): Promise<{
		id: string;
		status: string;
		paymentStatus: string;
		customerId?: string;
		metadata?: Record<string, unknown>;
	} | null>;

	// Webhook handling - must be implemented
	abstract handleWebhookEvent(event: {
		id: string;
		type: string;
		data: Record<string, unknown>;
		signature?: string;
		timestamp?: Date;
	}): Promise<void>;
	abstract verifyWebhookSignature(payload: string, signature: string): boolean;
	abstract getWebhookEvents(params?: {
		limit?: number;
		offset?: number;
		type?: string;
		processed?: boolean;
	}): Promise<{ events: WebhookEvent[]; hasMore: boolean }>;

	// Data operations - must be implemented
	abstract importPayments(options?: {
		startDate?: Date;
		endDate?: Date;
		dryRun?: boolean;
	}): Promise<EnhancedImportStats>;
	abstract exportOrders(params: {
		format: "csv" | "json" | "xlsx";
		startDate?: Date;
		endDate?: Date;
		status?: PaymentStatus[];
	}): Promise<{
		url: string;
		expiresAt: Date;
		totalRecords: number;
	}>;

	// Product management - can be optionally overridden
	async createProduct(data: Partial<EnhancedProductData>): Promise<EnhancedProductData> {
		throw new EnhancedPaymentProviderError(
			"Product creation not supported",
			this.id,
			"not_supported"
		);
	}

	async getProduct(productId: string): Promise<EnhancedProductData | null> {
		logger.warn(`Product retrieval not implemented for ${this.name}`, { productId });
		return null;
	}

	async updateProduct(productId: string, data: Partial<EnhancedProductData>): Promise<EnhancedProductData> {
		throw new EnhancedPaymentProviderError(
			"Product updates not supported",
			this.id,
			"not_supported"
		);
	}

	async deleteProduct(productId: string): Promise<boolean> {
		throw new EnhancedPaymentProviderError(
			"Product deletion not supported",
			this.id,
			"not_supported"
		);
	}

	async listProducts(params?: {
		limit?: number;
		offset?: number;
		isActive?: boolean;
		category?: string;
	}): Promise<{ products: EnhancedProductData[]; hasMore: boolean; total?: number }> {
		logger.warn(`Product listing not implemented for ${this.name}`);
		return { products: [], hasMore: false, total: 0 };
	}

	// Common utility implementations
	async getStatus(): Promise<{
		isHealthy: boolean;
		lastChecked: Date;
		responseTime: number;
		errors?: string[];
	}> {
		const startTime = Date.now();
		
		try {
			const isHealthy = await this.healthCheck();
			const responseTime = Date.now() - startTime;
			
			this._isHealthy = isHealthy;
			this._lastHealthCheck = new Date();
			
			return {
				isHealthy,
				lastChecked: this._lastHealthCheck,
				responseTime,
			};
		} catch (error) {
			const responseTime = Date.now() - startTime;
			const errorMessage = error instanceof Error ? error.message : String(error);
			
			this._isHealthy = false;
			this._lastHealthCheck = new Date();
			
			return {
				isHealthy: false,
				lastChecked: this._lastHealthCheck,
				responseTime,
				errors: [errorMessage],
			};
		}
	}

	// Analytics placeholder implementation
	async getAnalytics(params: {
		startDate: Date;
		endDate: Date;
		granularity: "day" | "week" | "month";
		metrics: ("revenue" | "orders" | "customers" | "subscriptions")[];
	}): Promise<{
		metrics: Record<string, Array<{ date: Date; value: number }>>;
		totals: Record<string, number>;
	}> {
		logger.warn(`Analytics not implemented for ${this.name}`, { params });
		return {
			metrics: {},
			totals: {},
		};
	}

	// Common validation implementation
	validatePaymentData(data: unknown): ValidationResult {
		const errors: ValidationError[] = [];
		const warnings: ValidationWarning[] = [];

		// Basic validation - can be overridden by specific providers
		if (!data || typeof data !== "object") {
			errors.push({
				field: "data",
				code: "invalid_type",
				message: "Payment data must be an object",
				value: data,
			});
		}

		return {
			isValid: errors.length === 0,
			errors,
			warnings,
		};
	}

	// Common data sanitization
	sanitizeCustomerData(data: Partial<CustomerData>): Partial<CustomerData> {
		const sanitized: Partial<CustomerData> = {};

		if (data.email) {
			sanitized.email = data.email.toLowerCase().trim();
		}

		if (data.name) {
			sanitized.name = data.name.trim();
		}

		if (data.phone) {
			// Remove non-numeric characters except + for country code
			sanitized.phone = data.phone.replace(/[^\d+]/g, "");
		}

		if (data.address) {
			sanitized.address = {
				line1: data.address.line1?.trim() ?? "",
				line2: data.address.line2?.trim(),
				city: data.address.city?.trim() ?? "",
				state: data.address.state?.trim(),
				postalCode: data.address.postalCode?.trim() ?? "",
				country: data.address.country?.trim() ?? "",
			};
		}

		return sanitized;
	}

	// Common amount formatting
	formatAmount(amount: number, currency: string): string {
		const formatter = new Intl.NumberFormat("en-US", {
			style: "currency",
			currency: currency.toUpperCase(),
		});
		return formatter.format(amount);
	}

	// Common amount parsing
	parseAmount(formattedAmount: string, currency: string): number {
		// Remove currency symbols and parse
		const cleanAmount = formattedAmount.replace(/[^\d.-]/g, "");
		return Number.parseFloat(cleanAmount) || 0;
	}

	// Default currency support
	getSupportedCurrencies(): string[] {
		return ["USD", "EUR", "GBP"]; // Override in specific providers
	}

	getMinimumAmount(currency: string): number {
		// Default minimums - override in specific providers
		const minimums: Record<string, number> = {
			USD: 0.5,
			EUR: 0.5,
			GBP: 0.3,
		};
		return minimums[currency.toUpperCase()] ?? 1.0;
	}

	getMaximumAmount(currency: string): number {
		// Default maximums - override in specific providers
		const maximums: Record<string, number> = {
			USD: 999999.99,
			EUR: 999999.99,
			GBP: 999999.99,
		};
		return maximums[currency.toUpperCase()] ?? 999999.99;
	}

	// Common error handling
	protected handleError(
		error: unknown,
		message = "Payment adapter error",
		code = "unknown_error",
		retryable = false
	): never {
		let errorMessage = message;
		let statusCode: number | undefined;
		let metadata: Record<string, unknown> | undefined;

		if (error instanceof Error) {
			errorMessage = `${message}: ${error.message}`;
			
			// Extract additional information from specific error types
			if (error instanceof EnhancedPaymentProviderError) {
				throw error; // Re-throw if already our error type
			}
			
			logger.error(errorMessage, {
				provider: this.id,
				error: error.stack,
				code,
			});

			throw new EnhancedPaymentProviderError(
				errorMessage,
				this.id,
				code,
				statusCode,
				retryable,
				error,
				metadata
			);
		}

		errorMessage = `${message}: ${String(error)}`;
		logger.error(errorMessage, {
			provider: this.id,
			error,
			code,
		});

		throw new EnhancedPaymentProviderError(
			errorMessage,
			this.id,
			code,
			statusCode,
			retryable,
			undefined,
			metadata
		);
	}

	// Protected helper for getting user email
	protected async getUserEmail(userId: string): Promise<string | null> {
		try {
			if (!db) {
				logger.warn("Database not initialized when getting user email", {
					userId,
					provider: this.id,
				});
				return null;
			}

			const user = await db
				.select({ email: users.email })
				.from(users)
				.where(eq(users.id, userId))
				.limit(1)
				.then((rows) => rows[0] || null);

			return user?.email ?? null;
		} catch (error) {
			logger.error("Error getting user email", {
				provider: this.id,
				userId,
				error,
			});
			return null;
		}
	}

	// Protected helper for configuration validation
	protected checkAdapterReady(): void {
		if (!this._isConfigured) {
			throw new EnhancedPaymentProviderError(
				`Payment adapter ${this.name} is not properly configured`,
				this.id,
				"adapter_not_configured"
			);
		}

		if (!this._isEnabled) {
			throw new EnhancedPaymentProviderError(
				`Payment adapter ${this.name} is not enabled`,
				this.id,
				"adapter_disabled"
			);
		}
	}
}
```

Now, let me create a migration guide and updated type definitions:

```typescript:src/server/providers/enhanced-types.ts
/**
 * Enhanced type definitions for payment adapters
 * Supporting LemonSqueezy, Stripe, and Polar SH
 */

// Re-export all enhanced types for easy import
export type {
	CustomerData,
	AddressData,
	EnhancedProductData,
	EnhancedOrderData,
	OrderLineItem,
	SubscriptionData,
	WebhookEvent,
	EnhancedCheckoutOptions,
	ShippingOption,
	EnhancedImportStats,
	EnhancedProviderConfig,
	RetryConfig,
	ProviderCapabilities,
	ValidationResult,
	ValidationError,
	ValidationWarning,
	IEnhancedPaymentAdapter,
} from "./enhanced-payment-adapter";

export {
	PaymentMethod,
	PaymentStatus,
	SubscriptionStatus,
	EnhancedPaymentProviderError,
	EnhancedPaymentAdapter,
} from "./enhanced-payment-adapter";

/**
 * Provider-specific configuration interfaces
 */

export interface LemonSqueezyConfig extends EnhancedProviderConfig {
	readonly storeId?: string;
	readonly sandboxMode?: boolean;
	readonly webhookSecret: string;
}

export interface StripeConfig extends EnhancedProviderConfig {
	readonly publishableKey: string;
	readonly webhookSecret: string;
	readonly apiVersion?: string;
	readonly maxNetworkRetries?: number;
	readonly telemetry?: boolean;
}

export interface PolarConfig extends EnhancedProviderConfig {
	readonly organizationId?: string;
	readonly webhookSecret: string;
	readonly sandboxMode?: boolean;
}

/**
 * Registry for payment adapters
 */
export interface PaymentAdapterRegistry {
	register(adapter: IEnhancedPaymentAdapter): void;
	unregister(adapterId: string): void;
	get(adapterId: string): IEnhancedPaymentAdapter | null;
	getAll(): IEnhancedPaymentAdapter[];
	getEnabled(): IEnhancedPaymentAdapter[];
	count: number;
	enabledCount: number;
}

/**
 * Payment adapter factory interface
 */
export interface PaymentAdapterFactory {
	createLemonSqueezyAdapter(config: LemonSqueezyConfig): IEnhancedPaymentAdapter;
	createStripeAdapter(config: StripeConfig): IEnhancedPaymentAdapter;
	createPolarAdapter(config: PolarConfig): IEnhancedPaymentAdapter;
}

/**
 * Service layer interface for payment operations
 */
export interface PaymentService {
	// Multi-provider operations
	getUserPaymentStatus(userId: string): Promise<boolean>;
	hasUserPurchasedProduct(userId: string, productId: string, provider?: string): Promise<boolean>;
	getUserPurchasedProducts(userId: string, provider?: string): Promise<EnhancedProductData[]>;
	
	// Aggregated operations
	getAllOrdersAcrossProviders(params?: {
		userId?: string;
		startDate?: Date;
		endDate?: Date;
		providers?: string[];
	}): Promise<EnhancedOrderData[]>;
	
	// Provider management
	getEnabledProviders(): IEnhancedPaymentAdapter[];
	getProviderById(id: string): IEnhancedPaymentAdapter | null;
	initializeProviders(): Promise<void>;
}
```

And here's a migration guide for your existing providers:

```typescript:docs/development/enhanced-payment-adapter-migration.md
# Enhanced Payment Adapter Migration Guide

## Overview

This document outlines the migration from the current `BasePaymentProvider` to the new `EnhancedPaymentAdapter` system. The new system provides:

- **Unified Interface**: Consistent API across all payment providers
- **Enhanced Type Safety**: Comprehensive TypeScript interfaces
- **Better Error Handling**: Structured error responses with retry logic
- **Advanced Features**: Customer management, analytics, and subscription handling
- **Enterprise Patterns**: Following Next.js best practices for scalable applications

## Key Benefits

### 1. Standardized Data Models
- **Unified Status Enums**: Consistent payment and subscription statuses
- **Rich Data Structures**: Comprehensive customer, order, and product interfaces
- **Metadata Support**: Extensible data storage for custom fields

### 2. Advanced Error Handling
- **Structured Errors**: Type-safe error responses with error codes
- **Retry Logic**: Built-in retry mechanisms for transient failures
- **Detailed Logging**: Enhanced logging with structured metadata

### 3. Enterprise Features
- **Health Checks**: Monitor provider availability and performance
- **Analytics**: Built-in reporting capabilities
- **Validation**: Input validation with detailed error messages
- **Configuration Management**: Environment-based configuration with validation

## Migration Steps

### Step 1: Update Provider Interfaces

**Before (Current)**:
```typescript
export class LemonSqueezyProvider extends BasePaymentProvider {
  readonly name = "Lemon Squeezy";
  readonly id = "lemonsqueezy";
  
  async getPaymentStatus(userId: string): Promise<boolean> {
    // Implementation
  }
}
```

**After (Enhanced)**:
```typescript
export class LemonSqueezyAdapter extends EnhancedPaymentAdapter {
  readonly name = "Lemon Squeezy";
  readonly id = "lemonsqueezy";
  readonly version = "1.0.0";
  readonly capabilities: ProviderCapabilities = {
    supportsSubscriptions: true,
    supportsRefunds: true,
    supportsPartialRefunds: false,
    supportsDisputes: false,
    supportsWebhooks: true,
    supportsMultiCurrency: true,
    supportedPaymentMethods: [PaymentMethod.CARD, PaymentMethod.BANK_TRANSFER],
    supportedCountries: ["US", "CA", "EU"],
    supportedCurrencies: ["USD", "EUR", "CAD"],
    minimumAmount: { USD: 1.00, EUR: 1.00, CAD: 1.00 },
    maximumAmount: { USD: 999999.99, EUR: 999999.99, CAD: 999999.99 },
  };

  async initialize(config: EnhancedProviderConfig): Promise<void> {
    // Enhanced initialization with validation
  }

  async getPaymentStatus(userId: string): Promise<boolean> {
    // Implementation with enhanced error handling
  }
}
```

### Step 2: Implement Required Methods

All adapters must implement these core methods:

```typescript
// Customer Management
async createCustomer(data: Partial<CustomerData>): Promise<CustomerData>
async getCustomer(customerId: string): Promise<CustomerData | null>
async getCustomerByEmail(email: string): Promise<CustomerData | null>

// Payment Operations  
async processPayment(paymentData): Promise<EnhancedOrderData>
async refundPayment(orderId: string, amount?: number): Promise<RefundResult>

// Order Management
async getOrder(orderId: string): Promise<EnhancedOrderData | null>
async getAllOrders(params?): Promise<PaginatedOrders>

// Subscription Management
async createSubscription(data): Promise<SubscriptionData>
async cancelSubscription(subscriptionId: string): Promise<SubscriptionData>

// Checkout Operations
async createCheckoutSession(options): Promise<CheckoutSession>

// Webhook Handling
async handleWebhookEvent(event): Promise<void>
async verifyWebhookSignature(payload: string, signature: string): boolean
```

### Step 3: Update Error Handling

**Before**:
```typescript
catch (error) {
  console.error("Error:", error);
  throw new Error("Payment failed");
}
```

**After**:
```typescript
catch (error) {
  this.handleError(
    error,
    "Failed to process payment",
    "payment_processing_failed",
    true // retryable
  );
}
```

### Step 4: Update Configuration

**Before**:
```typescript
interface ProviderConfig {
  apiKey?: string;
  enabled?: boolean;
}
```

**After**:
```typescript
interface LemonSqueezyConfig extends EnhancedProviderConfig {
  readonly apiKey: string;
  readonly webhookSecret: string;
  readonly storeId?: string;
  readonly environment: "sandbox" | "production";
  readonly retryConfig?: RetryConfig;
}
```

## Provider-Specific Migration

### LemonSqueezy Adapter

```typescript
export class LemonSqueezyAdapter extends EnhancedPaymentAdapter {
  readonly name = "Lemon Squeezy";
  readonly id = "lemonsqueezy";
  readonly version = "1.0.0";
  readonly capabilities: ProviderCapabilities = {
    supportsSubscriptions: true,
    supportsRefunds: true,
    supportsPartialRefunds: false,
    // ... other capabilities
  };

  async validateConfig(config: EnhancedProviderConfig): ValidationResult {
    const errors: ValidationError[] = [];
    
    if (!config.apiKey) {
      errors.push({
        field: "apiKey",
        code: "required",
        message: "LemonSqueezy API key is required",
      });
    }
    
    return { isValid: errors.length === 0, errors, warnings: [] };
  }

  async healthCheck(): Promise<boolean> {
    try {
      // Check LemonSqueezy API health
      const response = await fetch("https://api.lemonsqueezy.com/v1/stores", {
        headers: { Authorization: `Bearer ${this._config?.apiKey}` }
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  // Implement all required methods...
}
```

### Stripe Adapter

```typescript
export class StripeAdapter extends EnhancedPaymentAdapter {
  readonly name = "Stripe";
  readonly id = "stripe";
  readonly version = "1.0.0";
  readonly capabilities: ProviderCapabilities = {
    supportsSubscriptions: true,
    supportsRefunds: true,
    supportsPartialRefunds: true,
    supportsDisputes: true,
    // ... other capabilities
  };

  async createCheckoutSession(options: EnhancedCheckoutOptions): Promise<{
    sessionId: string;
    url: string;
    expiresAt: Date;
  }> {
    this.checkAdapterReady();
    
    try {
      const session = await this.stripe.checkout.sessions.create({
        mode: options.mode,
        line_items: [{
          price: options.priceId,
          quantity: options.quantity ?? 1,
        }],
        success_url: options.successUrl,
        cancel_url: options.cancelUrl,
        customer_email: options.customerEmail,
        metadata: options.metadata,
      });

      return {
        sessionId: session.id,
        url: session.url!,
        expiresAt: new Date(session.expires_at * 1000),
      };
    } catch (error) {
      this.handleError(error, "Failed to create Stripe checkout session");
    }
  }

  // Implement all required methods...
}
```

### Polar SH Adapter

```typescript
export class PolarAdapter extends EnhancedPaymentAdapter {
  readonly name = "Polar";
  readonly id = "polar";
  readonly version = "1.0.0";
  readonly capabilities: ProviderCapabilities = {
    supportsSubscriptions: true,
    supportsRefunds: false, // Polar may not support refunds
    supportsPartialRefunds: false,
    // ... other capabilities
  };

  // Implement all required methods...
}
```

## Registry and Service Updates

### Enhanced Registry

```typescript
class EnhancedPaymentAdapterRegistry implements PaymentAdapterRegistry {
  private adapters = new Map<string, IEnhancedPaymentAdapter>();

  register(adapter: IEnhancedPaymentAdapter): void {
    this.adapters.set(adapter.id, adapter);
    logger.info(`Registered payment adapter: ${adapter.name}`, {
      id: adapter.id,
      version: adapter.version,
      capabilities: adapter.capabilities,
    });
  }

  get(adapterId: string): IEnhancedPaymentAdapter | null {
    return this.adapters.get(adapterId) ?? null;
  }

  getEnabled(): IEnhancedPaymentAdapter[] {
    return Array.from(this.adapters.values()).filter(adapter => adapter.isEnabled);
  }

  get count(): number {
    return this.adapters.size;
  }

  get enabledCount(): number {
    return this.getEnabled().length;
  }
}
```

### Enhanced Service Layer

```typescript
export class EnhancedPaymentService implements PaymentService {
  constructor(private registry: PaymentAdapterRegistry) {}

  async getUserPaymentStatus(userId: string): Promise<boolean> {
    const enabledAdapters = this.registry.getEnabled();
    
    if (enabledAdapters.length === 0) {
      logger.warn("No payment adapters are enabled");
      return false;
    }

    // Check payment status across all enabled adapters
    const statusChecks = enabledAdapters.map(async adapter => {
      try {
        return await adapter.getPaymentStatus(userId);
      } catch (error) {
        logger.error(`Error checking payment status with ${adapter.name}`, {
          userId,
          adapterId: adapter.id,
          error,
        });
        return false;
      }
    });

    const results = await Promise.all(statusChecks);
    return results.some(status => status === true);
  }

  // Implement other service methods...
}
```

## Testing Strategy

### Unit Tests

```typescript
describe("EnhancedPaymentAdapter", () => {
  let adapter: LemonSqueezyAdapter;
  let mockConfig: LemonSqueezyConfig;

  beforeEach(() => {
    adapter = new LemonSqueezyAdapter();
    mockConfig = {
      apiKey: "test-api-key",
      webhookSecret: "test-webhook-secret",
      environment: "sandbox",
      enabled: true,
    };
  });

  describe("initialization", () => {
    it("should validate configuration correctly", async () => {
      const result = adapter.validateConfig(mockConfig);
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it("should fail validation with missing API key", async () => {
      const invalidConfig = { ...mockConfig, apiKey: "" };
      const result = adapter.validateConfig(invalidConfig);
      expect(result.isValid).toBe(false);
      expect(result.errors).toContainEqual(
        expect.objectContaining({
          field: "apiKey",
          code: "required",
        })
      );
    });
  });

  describe("health checks", () => {
    it("should return true when API is healthy", async () => {
      // Mock healthy API response
      fetchMock.mock

---

